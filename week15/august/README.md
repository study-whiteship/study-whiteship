# [Week15] 람다식

최근 들어 함수적 프로그래밍이 다시 부각되고 있는데, 이는 병렬 처리와 이벤트 지향 프로그래밍에 적합하기 때문이다. 그래서 객체 제향 프로그래밍과 함수적 프로그래밍을 적절히 혼합함으로써 더욱 효율적인 프로그래밍이 될 수 있도록 언어도 계속 변하고 있다.

자바8부터 람다식(Lambda Expressions)을 지원하면서 기존의 코드 패턴이 많이 달라졌다. 람다식은 익명 함수(anonymous function)를 생성하기 위한 식으로 객체 지향 언어보다는 함수지향 언어에 가깝다. 객체 지향 프로그래밍에 익숙한 개발자들은 다소 혼란스러울 수 있지만, 자바에서 람다식을 수용한 이유는 자바 코드가 매우 간결해지고, 컬렉션의 요소를 필터링(filter)하거나 매핑(map)해서 원하는 결과를 쉽게 집계할 수 있기 때문이다. 람다식의 형태는 매개 변수를 가진 코드 블록이지만, 런타임 시에는 익명 구현 객체를 생성한다.

```
람다식 → 매개 변수를 가진 코드 블록 → 익명 구현 객체
```

예를 들어, Runnable 인터페이스의 익명 구현 객체를 생성하는 전형적인 코드는 다음과 같다.

```java
Runnable runnable = new Runnable() {
		public void run() {...}
}
```

```java
Runnable runnable = () -> {...};
```

위 코드는 Runnable 변수에 대입되므로 람다식은 Runnable의 익명 구현 객체를 생성하게 된다.

---

## 람다식 사용법

함수적 스타일의 람다식을 작성하는 방법은 다음과 같다.

```java
(타입 매개변수, ...) -> {실행문; ...}
```

타입 매개변수는 `{}` 블록을 실행하기 위해 필요한 값을 제공하는 역할을 한다. 매개 변수의 이름은 개발자가 자유롭게 줄 수 있다. `->` 기호는 매개 변수를 이용해서 중괄호 `{}`를 실행한다는 뜻으로 해석할 수 있다. 

예를 들어, int형 매개 변수 a의 값을 콘솔에 출력하기 위한 람다식 코드는 다음과 같다.

```java
(int a) -> { System.out.println(a); }
```

하나의 매개 변수만 있다면 괄호 생략이 가능하고, 블록도 마찬가지로 생략이 가능하다.

```java
a -> System.out.println(a);
```

만약 매개 변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 다음과 같이 빈 괄호를 반드시 사용해야 한다.

```java
() -> { 실행문; ... }
```

중괄호 `{}`를 실행하고 결과값을 리턴해야 한다면 다음과 같이 return문으로 결과값을 지정할 수 있다.

```java
(x, y) -> { return x + y; };
```

중괄호 `{}`에 return문만 있을 경우, 람다식에서는 return문을 사용하지 않고 다음과 같이 작성하는 것이 정석이다.

```java
(x, y) -> x + y
```

---

## 함수형 인터페이스

모든 인터페이스를 람다식의 타겟 타입으로 사용할 수는 없다. 람다식이 하나의 메소드를 정의하기 때문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없다. 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있는데, 이러한 인터페이스를 함수적 인터페이스(functional interface)라고 한다. 

### @FunctionalInterface

함수적 인터페이스를 작성할 때 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능이 있는데, 인터페이스 선언 시 `@FunctionalInterface` 애노테이션을 붙이면 된다. 이 애노테이션은 두 개 이상의 추상 메소드가 선언되면 컴파일 오류를 발생시킨다.

```java
@FunctionalInterface
public interface MyFunctionalInterface {
		public void method();
		public void otherMethod(); // compile error
}
```

### 매개 변수와 리턴값이 없는 람다식

```java
@FunctionalInterface
public interface MyFuncionalInterface {
		public void method();
}
```

```java
MyFuncionalInterface fi = () -> {...}
```

람다식이 대입된 인터페이스의 참조 변수는 다음과 같이 `method()`를 호출할 수 있다. 이렇게 호출하면 람다식의 중괄호 `{}` 내용을 실행시킨다.

```java
fi.method();
```

### 매개 변수가 있는 람다식

```java
@FunctionalInterface
public interface MyFunctionalInterface {
		public void method(int x);
}
```

```java
MyFunctionalInterface fi = (x) -> {...} or x -> {...}
```

람다식이 대입된 인터페이스의 참조 변수는 다음과 같이 `method()`를 호출할 수 있다. 매개값으로 5를 주면 람다식의 x 변수에 5가 대입되고 x는 중괄호 `{}` 에서 사용된다.

```java
fi.method(5);
```

### 리턴값이 있는 람다식

```java
@FunctionalInterface
public interface MyFunctionalInterface {
		public int method(int x, int y);
}
```

```java
MyFunctionalInterface fi = (x, y) -> { ...; return 값; }
```

만약 중괄호에 return문만 있고, return문 뒤에 연산식이나 메소드 호출이 오는 경우라면 다음과 같이 작성할 수 있다. (중괄호 생략 가능)

```java
MyFunctionalInterface fi = (x, y) -> { return x + y; }
```

```java
MyFunctionalInterface fi = (x, y) -> x + y
```

```java
MyFunctionalInterface fi = (x, y) -> { return sum(x, y); }
```

```java
MyFunctionalInterface fi = (x, y) -> sum(x, y);
```

람다식이 대입된 인터페이스의 참조 변수는 다음과 같이 `method()`를 호출할 수 있다. 매개값으로 각각 주면 람다식에서 사용된다.

```java
int result = fi.method(2, 5);
```

---

## 표준 API의 함수형 인터페이스

자바에서 제공되는 표준 API에서 한 개의 추상 메소드를 가지는 인터페이스들은 모두 람다식을 이용해서 익명 구현 객체로 표현이 가능하다.

가장 기본적인 함수형 인터페이스로서 매개값도 없고, 리턴값도 없는 인터페이스는 Runnable이다.

```java
Runnable runnable = () -> {...}
```

자바8 부터는 빈번하게 사용되는 함수형 인터페이스는 java.util.function 표준 API 패키지로 제공한다. 이 패키지에서 제공하는 함수형 인터페이스의 목적은 메소드 또는 생성자의 매개 타입으로 사용되어 람다식을 대입할 수 있도록 하기 위해서이다. java.util.function의 함수형 인터페이스는 크게 5가지로 구분된다. 구분 기분은 인터페이스에 선언된 추상 메소드의 매개값과 리턴값의 유무이다.

| 종류      | 매개값과 리턴값 유무       | 추상 메소드 특징                         |
| --------- | -------------------------- | ---------------------------------------- |
| Consumer  | 매개값 O, 리턴값 X         |                                          |
| Supplier  | 매개값 X, 리턴값 O         |                                          |
| Function  | 매개값 O, 리턴값 O         | 주로 매개값을 리턴값으로 매핑(타입 변환) |
| Operator  | 매개값 O, 리턴값 O         | 주로 매개값을 연산하고 결과를 리턴       |
| Predicate | 매개값은 O, 리턴값 boolean | 매개값을 조사해서 true/false 리턴        |

---

## Variable Capture

자바에서 람다식은 특정 상황에 대해 람다식 블록 외부에 선언된 변수에 접근이 가능하도록 허용한다. 자바8 이전에는 익명 내부 클래스가 감싸고 있는 메소드에 대한 로컬 변수를 캡처할 때 문제가 발생했다. 따라서 final을 붙여주어야 했다.

캡처된 변수는 중첩 된 클래스에서 사용할 수 있도록 복사 된 변수이다. 복사해야하는 이유는 객체가 현재 컨텍스트를 벗어날 수 있기 때문이다. `final` 이어야하므로 변수에 대한 변경 사항이 표시되는지 여부에 대한 혼동이 없다. 

NOTE : Groovy에는이 규칙이 있으며 로컬 변수를 변경하면 둘러싸는 클래스의 값이 변경 될 수 있으며, 이는 여러 스레드가 관련되어있는 경우 특히 혼란스럽다.

---

## 메소드, 생성자 레퍼런스

### 메소드 참조

메소드 참조(Method References)는 말 그대로 메소드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개 변수를 제거하는 것이 목적이다. 람다식은 종종 기존 메소드를 단순히 호출만 하는 경우가 많다. 예를 들어, 두 개의 값을 받아 큰 수를 리턴하는 Math 클래스의 max() 정적 메소드를 호출하는 람다식은 다음과 같다.

```java
(x1, x2) -> Math.max(x1, x2)
```

람다식은 단순히 두 개의 값을 Math.max() 메소드의 매개값으로 전달하는 역할만 하기 때문에 다소 불편해 보인다. 이 경우에는 다음과 같이 메소드 참조를 이용하면 매우 깔끔하게 처리할 수 있다.

```java
Math :: max;
```

메소드 참조도 람다식과 마찬가지로 인터페이스의 익명 구현 객체로 생성되므로 타겟 타입인 인터페이스의 추상 메소드가 어떤 매개 변수를 가지고, 리턴 타입이 무엇인가에 따라 달라진다. IntBinaryOperator 인터페이스는 두 개의 int 매개값을 받아 int 값을 리턴하므로 Math :: max 메소드 참조를 대입할 수 있다.

```java
IntBinaryOperator operator = Math :: max;
```

- 정적 메소드 참조

```java
클래스 :: 메소드
```

- 인스턴스 메소드 참조

```java
참조변수 :: 메소드
```

- 매개 변수의 메소드 참조

메소드는 람다식 외부의 클래스 멤버일 수도 있고, 람다식에서 제공되는 매개 변수의 멤버일 수도 있다. 다음과 같이 람다식에서 제공되는 a 매개 변수의 메소드를 호출해서 b 매개 변수를 매개값으로 사용하는 경우도 가능하다.

```java
(a, b) -> { a.instanceMethod(b); }
```

이것을 메소드 참조로 표현하면 다음과 같다. a의 클래스 이름 뒤에 :: 기호를 붙이고 메소드 이름을 기술하면 된다. 작성 방법은 정적 메소드 참조와 동일하지만, a의 인스턴스 메소드가 참조되므로 전혀 다른 코드가 실행된다.

```java
클래스 :: instanceMethod
```

### 생성자 참조

메소드 참조는 생성자 참조도 포함한다. (-> 생성자도 일종의 메소드로 볼 수 있으므로) 생성자를 참조한다는 것은 객체 생성을 의미한다. 단순히 메소드 호출로 구성된 람다식을 메소드 참조로 대치할 수 있듯이, 단순히 객체를 생성하고 리턴하도록 구성된 람다식은 생성자 참조로 대치할 수 있다.

```java
(a, b) -> { return new 클래스(a, b); }
```

위의 코드는 단순히 객체 생성 후 리턴만 한다. 이 경우, 생성자 참조로 표현하면 다음과 같다. 클래스 이름 뒤에 :: 기호를 붙이고 new 연산자를 기술하면 된다. 생성자가 오버로딩되어 여러 개가 있을 경우, 컴파일러는 함수형 인터페이스의 추상 메소드와 동일한 매개 변수 타입과 개수를 가지고 있는 생성자를 찾아 실행한다. 만약 해당 생성자가 존재하지 않으면 컴파일 오류가 발생한다.

```java
클래스 :: new
```

```
Illegal :: new 
```



---

## References

- https://sujl95.tistory.com/76
- https://stackoverflow.com/questions/22025161/what-are-captured-variables-in-java-local-classes